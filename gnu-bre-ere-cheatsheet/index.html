<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><title>GNU BRE/ERE cheatsheet and differences between grep, sed and awk</title><link href=https://learnbyexample.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><link href=https://learnbyexample.github.io/site.css rel=stylesheet><link href=https://learnbyexample.github.io/favicon.svg rel=icon><link rel="shortcut icon" href=https://learnbyexample.github.io/favicon.png><body><div class=container><div class=mobile-navbar id=mobile-navbar><div class=mobile-header-logo><a class=logo href=/>learnbyexample</a></div><div class="mobile-navbar-icon icon-out"><span></span><span></span><span></span></div></div><nav class="mobile-menu slideout-menu slideout-menu-left" id=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a href=https://learnbyexample.github.io/books> Books </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/mini> Mini </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tips> Tips </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tags> Tags </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/about> About </a></ul></nav><header id=header><div class=logo><a href=https://learnbyexample.github.io>learnbyexample</a></div><nav class=menu><ul><li><a href=https://learnbyexample.github.io/books> Books </a><li><a href=https://learnbyexample.github.io/mini> Mini </a><li><a href=https://learnbyexample.github.io/tips> Tips </a><li><a href=https://learnbyexample.github.io/tags> Tags </a><li><a href=https://learnbyexample.github.io/about> About </a></ul></nav></header><main><div class=content id=mobile-panel><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#bre-and-ere>BRE and ERE</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#anchors>Anchors</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#alternation-and-grouping>Alternation and Grouping</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#escaping-metacharacters>Escaping metacharacters</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#dot-metacharacter-and-quantifiers>Dot metacharacter and Quantifiers</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#character-class>Character class</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#escape-sequences>Escape sequences</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#named-character-sets>Named character sets</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#backreferences>Backreferences</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#sed-flags>sed flags</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#sed-case-conversion>sed case conversion</a><li><a class=toc-link href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/#sed-delimiters>sed delimiters</a></ul></nav></div></div><article class=post><header class=post__header><h1 class=post__title><a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>GNU BRE/ERE cheatsheet and differences between grep, sed and awk</a></h1><div class=post__meta><span class=post__time>2021-05-31</span></div></header><div class=post-content><p align=center><img alt="GNU BRE/ERE cheatsheet" src=/images/bre_ere_cheatsheet.png><p>This post covers <strong>Basic Regular Expressions</strong> (BRE) and <strong>Extended Regular Expressions</strong> (ERE) syntax supported by GNU <code>grep</code>, <code>sed</code> and <code>awk</code>. You'll also learn the differences between these tools — for example, <code>awk</code> doesn't support backreferences within regexp definition (i.e. the search portion).</p><span id=continue-reading></span><br><h2 id=bre-and-ere>BRE and ERE<a aria-label="Anchor link for: bre-and-ere" class=zola-anchor href=#bre-and-ere>🔗</a></h2><p><img alt=info src=/images/info.svg> From <a href=https://www.gnu.org/software/grep/manual/grep.html#Basic-vs-Extended>GNU grep manual</a>:<blockquote><p>In basic regular expressions the meta-characters <code>?</code>, <code>+</code>, <code>{</code>, <code>|</code>, <code>(</code>, and <code>)</code> lose their special meaning; instead use the backslashed versions <code>\?</code>, <code>\+</code>, <code>\{</code>, <code>\|</code>, <code>\(</code>, and <code>\)</code>.</blockquote><p><code>grep</code> and <code>sed</code> support BRE by default and enables ERE when <code>-E</code> option is used. <code>awk</code> supports only ERE. Assume ERE for descriptions in this post unless otherwise mentioned.<p>This post is intended as a reference for BRE/ERE flavor of regular expressions. For a more detailed explanation with examples and exercises, see these chapters from <a href=https://learnbyexample.github.io/books/>my ebooks</a>:<ul><li><a href=https://learnbyexample.github.io/learn_gnugrep_ripgrep/breere-regular-expressions.html>grep BRE/ERE Regular Expressions</a><li><a href=https://learnbyexample.github.io/learn_gnused/breere-regular-expressions.html>sed BRE/ERE Regular Expressions</a><li><a href=https://learnbyexample.github.io/learn_gnuawk/regular-expressions.html>awk Regular Expressions</a></ul><br><h2 id=anchors>Anchors<a aria-label="Anchor link for: anchors" class=zola-anchor href=#anchors>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>^</code><td>restricts the match to the start of the string<tr><td><code>$</code><td>restricts the match to the end of the string<tr><td><code>\<</code><td>restricts the match to the start of word<tr><td><code>\></code><td>restricts the match to the end of word</table><p>The <code>-x</code> cli option in <code>grep</code> is equivalent to <code>^pattern$</code>.<p>Word characters include alphabets, digits and underscore. Here's some more alternate ways to specify word anchors:<table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>\b</code><td>restricts the match to the start/end of words, applicable for <code>grep</code> and <code>sed</code><tr><td><code>\y</code><td>restricts the match to the start/end of words, applicable for <code>awk</code> (<code>\b</code> means backspace)<tr><td><code>\B</code><td>matches wherever <code>\b</code> (or <code>\y</code>) doesn't match</table><p><code>grep</code> also supports <code>-w</code> cli option. It is equivalent to <code>(?&LT!\w)pattern(?!\w)</code>. The three different ways to specify word anchors are not exactly equivalent though, see <a href=https://learnbyexample.github.io/learn_gnugrep_ripgrep/gotchas-and-tricks.html#word-boundary-differences>Word boundary differences</a> section from my book for details and examples.</p><br><h2 id=alternation-and-grouping>Alternation and Grouping<a aria-label="Anchor link for: alternation-and-grouping" class=zola-anchor href=#alternation-and-grouping>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>pat1|pat2|pat3</code><td>match <code>pat1</code> or <code>pat2</code> or <code>pat3</code><tr><td><td>use <code>\|</code> in BRE mode<tr><td><code>()</code><td>group pattern(s), <code>a(b|c)d</code> is same as <code>abd|acd</code><tr><td><td>use <code>\(\)</code> in BRE mode</table><p>The alternative patterns can have their own independent anchors. Alternative which matches earliest in the input gets precedence. Longest matching portion wins if multiple alternatives start from the same location (irrespective of the order of alternatives). In case of a tie with same lengths, leftmost alternative wins (see <a href=https://stackoverflow.com/a/39752929/4082052>stackoverflow: Non greedy matching in sed</a> for a practical use case).</p><br><h2 id=escaping-metacharacters>Escaping metacharacters<a aria-label="Anchor link for: escaping-metacharacters" class=zola-anchor href=#escaping-metacharacters>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>\</code><td>prefix metacharacters with <code>\</code> to match them literally<tr><td><code>\\</code><td>to match <code>\</code> literally</table><ul><li>With <code>grep</code> and <code>sed</code>, switching between ERE and BRE can reduce the number of escapes needed for some cases. For fixed string matching, <code>grep</code> has <code>-F</code> option and <code>awk</code> has string comparison operators (whole string) and the <code>index</code> function (partial string).<li><code>sed</code> requires both <code>(</code> and <code>)</code> characters to be escaped (in ERE mode), whereas <code>grep</code> and <code>awk</code> don't require <code>)</code> to be escaped.<li><code>sed</code> requires <code>{</code> to be escaped (in ERE mode) even if it isn't part of a valid quantifier syntax, whereas <code>grep</code> and <code>awk</code> don't require escaping. For example, you'd need <code>\{a}</code> in <code>sed</code> whereas <code>{a}</code> is enough for the other two.<li>In BRE mode, <code>grep</code> and <code>sed</code> don't require <code>^</code> and <code>$</code> to be escaped if they are used away from their customary positions.</ul><br><h2 id=dot-metacharacter-and-quantifiers>Dot metacharacter and Quantifiers<a aria-label="Anchor link for: dot-metacharacter-and-quantifiers" class=zola-anchor href=#dot-metacharacter-and-quantifiers>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>.</code><td>match any character, including the newline character<tr><td><code>?</code><td>match <code>0</code> or <code>1</code> times<tr><td><td>use <code>\?</code> in BRE mode<tr><td><code>*</code><td>match <code>0</code> or more times<tr><td><code>+</code><td>match <code>1</code> or more times<tr><td><td>use <code>\+</code> in BRE mode<tr><td><code>{m,n}</code><td>match <code>m</code> to <code>n</code> times<tr><td><code>{m,}</code><td>match at least <code>m</code> times<tr><td><code>{,n}</code><td>match up to <code>n</code> times (including <code>0</code> times)<tr><td><code>{n}</code><td>match exactly <code>n</code> times<tr><td><td>use <code>\{\}</code> in BRE mode<tr><td><code>pat1.*pat2</code><td>any number of characters between <code>pat1</code> and <code>pat2</code><tr><td><code>pat1.*pat2|pat2.*pat1</code><td>match both <code>pat1</code> and <code>pat2</code> in any order</table><p>Precedence rule is <em>longest match wins</em>, which is mostly similar but not exactly same as greedy quantifiers. For example, with <code>foo123312baz</code> as input string, <code>o[123]+(12baz)?</code> will match <code>o123312baz</code> with these tools, whereas it will match <code>o123312</code> with greedy quantifiers.</p><br><h2 id=character-class>Character class<a aria-label="Anchor link for: character-class" class=zola-anchor href=#character-class>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>[set123]</code><td>match any of these characters once<tr><td><code>[^set123]</code><td>match except any of these characters once<tr><td><code>[3-7AM-X]</code><td>range of characters from <code>3</code> to <code>7</code>, <code>A</code>, another range from <code>M</code> to <code>X</code><tr><td><code>[.</code><td>open collating symbol<tr><td><code>.]</code><td>close collating symbol<tr><td><code>[=</code><td>open equivalence class<tr><td><code>=]</code><td>close equivalence class</table><p>Specific placement will help to match character class metacharacters literally.<table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>[a-z-]</code><td><code>-</code> should be first/last character to match literally<tr><td><code>[+^]</code><td><code>^</code> shouldn't be first character<tr><td><code>[]=]</code><td><code>]</code> should be first character (second if <code>^</code> is used to invert the set)</table><ul><li><code>\</code> isn't special within character class in <code>grep</code>.<li><code>\</code> can be used to escape character class metacharacters in <code>awk</code>.</ul><p>Some commonly used character sets have predefined escape sequences:<table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>\w</code><td>similar to <code>[a-zA-Z0-9_]</code> for matching word characters<tr><td><code>\s</code><td>similar to <code>[ \t\n\r\f\v]</code> for matching whitespace characters<tr><td><code>\W</code><td>match non-word characters<tr><td><code>\S</code><td>match non-whitespace characters</table><ul><li>Undefined escape sequences will be treated as the character it escapes. For example, <code>\e</code> will match <code>e</code> (not <code>\</code> and <code>e</code>). <ul><li>in addition, <code>awk</code> gives a "not a known regexp operator" warning.</ul><li>The above escape sequences <em>cannot</em> be used inside character classes and behavior varies between the tools. <ul><li>For example, using <code>[\w]</code> will match <code>\</code> or <code>w</code> characters in <code>grep</code> and <code>sed</code> whereas it will match only <code>w</code> in <code>awk</code>.</ul><li>These escape sequences are also locale aware, for example <code>αλεπού</code> and <code>\u2028</code> (line separator) will be considered as word and whitespace characters respectively in appropriate locales.<li>These tools do <em>not</em> support <code>\d</code> and <code>\D</code>, commonly featured in other regexp implementations for digits and non-digits.</ul><br><h2 id=escape-sequences>Escape sequences<a aria-label="Anchor link for: escape-sequences" class=zola-anchor href=#escape-sequences>🔗</a></h2><p>This section is applicable only for <code>sed</code> and <code>awk</code> unless otherwise specified and can be used within character classes too. See also <a href=https://ascii.cl/>ASCII Codes Table Standard characters</a>.<table><thead><tr><th>Escape sequence<th>Description<tbody><tr><td><code>\a</code><td>alert<tr><td><code>\b</code><td>backspace in <code>awk</code>, word boundary in <code>grep</code> and <code>sed</code><tr><td><td><code>\b</code> inside a character class in <code>sed</code> will act as a backspace<tr><td><code>\f</code><td>formfeed<tr><td><code>\n</code><td>newline<tr><td><code>\r</code><td>carriage return<tr><td><code>\t</code><td>horizontal tab<tr><td><code>\v</code><td>vertical tab<tr><td><code>\cx</code><td>CONTROL-x in <code>sed</code></table><p>You can also represent ASCII characters using their codepoint values.<table><thead><tr><th>Escape sequence<th>Description<tbody><tr><td><code>\xNN</code><td>hexadecimal digits<tr><td><code>\NNN</code><td>octal digits in <code>awk</code><tr><td><code>\oNNN</code><td>octal digits in <code>sed</code><tr><td><code>\dNNN</code><td>decimal digits in <code>sed</code></table><ul><li>In search section, a metacharacter specified by escape sequences will still act as the metacharacter. For example, <code>/\x5eco/</code> will match <code>co</code> only at the start of the string.<li>In replacement section, <ul><li>escape sequences in <code>sed</code> produces literal character. For example, <code>s/.*/"\x26"/</code> will have <code>"&"</code> as the replacement value.<li>escape sequences in <code>awk</code> is treated as metacharacter. For example, <code>sub(/.*/, "[&]")</code> and <code>sub(/.*/, "[\x26]")</code> are equivalent.</ul></ul><p><img alt=info src=/images/info.svg> Ways to use escape sequences with <code>grep</code>:<ul><li><a href=https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting>ANSI-C Quoting</a> — for example, <code>$'a\tb'</code> will match <code>a</code> and <code>b</code> with a tab in between.<li><code>-P</code> option, see my chapter on <a href=https://learnbyexample.github.io/learn_gnugrep_ripgrep/perl-compatible-regular-expressions.html>Perl Compatible Regular Expressions</a> for more details.</ul><br><h2 id=named-character-sets>Named character sets<a aria-label="Anchor link for: named-character-sets" class=zola-anchor href=#named-character-sets>🔗</a></h2><p>The below table lists named sets and their equivalent character class in ASCII encoding. These can be used inside character classes only. For example, <code>[[:digit:]]</code> is same as <code>[0-9]</code> and <code>[[:alnum:]_]</code> is equivalent to <code>\w</code>.<table><thead><tr><th>Named set<th>Description<tbody><tr><td><code>[:digit:]</code><td><code>[0-9]</code><tr><td><code>[:lower:]</code><td><code>[a-z]</code><tr><td><code>[:upper:]</code><td><code>[A-Z]</code><tr><td><code>[:alpha:]</code><td><code>[a-zA-Z]</code><tr><td><code>[:alnum:]</code><td><code>[0-9a-zA-Z]</code><tr><td><code>[:xdigit:]</code><td><code>[0-9a-fA-F]</code><tr><td><code>[:cntrl:]</code><td>control characters — first 32 ASCII characters and 127th (DEL)<tr><td><code>[:punct:]</code><td>all the punctuation characters<tr><td><code>[:graph:]</code><td><code>[:alnum:]</code> and <code>[:punct:]</code><tr><td><code>[:print:]</code><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space<tr><td><code>[:blank:]</code><td>space and tab characters<tr><td><code>[:space:]</code><td>whitespace characters, same as <code>\s</code></table><p><img alt=info src=/images/info.svg> From <a href=https://www.gnu.org/software/grep/manual/grep.html#Character-Classes-and-Bracket-Expressions>grep manual</a>:<blockquote><p>Their interpretation depends on the <code>LC_CTYPE</code> locale; for example, <code>[[:alnum:]]</code> means the character class of numbers and letters in the current locale.</blockquote><br><h2 id=backreferences>Backreferences<a aria-label="Anchor link for: backreferences" class=zola-anchor href=#backreferences>🔗</a></h2><table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>\N</code><td>backreference, gives matched portion of Nth capture group<tr><td><td>possible values: <code>\1</code>, <code>\2</code> up to <code>\9</code><tr><td><code>&</code><td>represents entire matched string in the replacement section<tr><td><code>\0</code><td>equivalent to <code>&</code> in <code>sed</code></table><p>Notes for <code>awk</code>:<ul><li>backreferences can be used only in replacement section, not allowed in search section.<li><code>sub</code> and <code>gsub</code> functions allow only the <code>&</code> backreference.<li><code>gensub</code> function allows <code>\N</code> form of backreference as well. <ul><li>but need to use <code>\\0</code>, <code>\\1</code>, <code>\\2</code> etc since they are specified using string syntax.</ul></ul><br><h2 id=sed-flags>sed flags<a aria-label="Anchor link for: sed-flags" class=zola-anchor href=#sed-flags>🔗</a></h2><p>This section discusses flags (also known as modifiers) that change the regexp behavior. When used with regexp addressing:<table><thead><tr><th>Flag<th>Description<tbody><tr><td><code>I</code><td>match case insensitively</table><p>When used with substitution command:<table><thead><tr><th>Flag<th>Description<tbody><tr><td><code>i</code> or <code>I</code><td>match case insensitively<tr><td><code>g</code><td>replace all occurrences instead of just the first match<tr><td><code>N</code><td>a number will cause only the <em>N</em>th match to be replaced<tr><td><code>Ng</code><td>replace from <em>N</em>th match to the end<tr><td><code>m</code> or <code>M</code><td>multiline mode<tr><td><td><code>.</code> will not match the newline character<tr><td><td><code>^</code> and <code>$</code> will match every line's start and end locations (line separator is <code>\n</code> by default and NUL when <code>-z</code> option is used)<tr><td><code>\`</code><td>always match the start of string irrespective of multiline mode<tr><td><code>\'</code><td>always match the end of string irrespective of multiline mode</table><p>Flags are not supported by <code>grep</code> or <code>awk</code>. But these equivalent/alternative options can be used:<ul><li><code>-i</code> cli option in <code>grep</code> and setting <code>IGNORECASE</code> to non-zero value in <code>awk</code> will match case insensitively.<li><code>tolower</code> or <code>toupper</code> functions can be used in <code>awk</code> to convert input to single case.<li>you can also use character classes for small strings, for example <code>[cC][aA][tT]</code> will match <code>cat</code> case insensitively.<li><code>sub</code> function in <code>awk</code> replaces only the first matching occurrence and <code>gsub</code> function is equivalent to using the <code>g</code> flag.<li>third argument of <code>gensub</code> function in <code>awk</code> supports replacing only the <em>N</em>th match as well as the <code>g</code> flag.</ul><p>The behavior of <code>sed</code> and <code>awk</code> differs for <em>N</em>th match if the pattern can match empty string:<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ echo </span><span style=color:#d07711;>'a,,c,d,,f' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/[^,]*/b/2'
</span><span>a,b,c,d,,f
</span><span>$ echo </span><span style=color:#d07711;>'a,,c,d,,f' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/[^,]*/e/5'
</span><span>a,,c,d,e,f
</span><span>
</span><span>$ echo </span><span style=color:#d07711;>'a,,c,d,,f' </span><span style=color:#72ab00;>|</span><span> awk </span><span style=color:#d07711;>'{print gensub(/[^,]*/, "b", 2)}'
</span><span>ab,,c,d,,f
</span><span>$ echo </span><span style=color:#d07711;>'a,,c,d,,f' </span><span style=color:#72ab00;>|</span><span> awk </span><span style=color:#d07711;>'{print gensub(/[^,]*/, "e", 5)}'
</span><span>a,,ce,d,,f
</span></code></pre><br><h2 id=sed-case-conversion>sed case conversion<a aria-label="Anchor link for: sed-case-conversion" class=zola-anchor href=#sed-case-conversion>🔗</a></h2><table><thead><tr><th>Escape sequence<th>Description<tbody><tr><td><code>\E</code><td>indicates end of case conversion in replacement section<tr><td><code>\l</code><td>convert next character to lowercase<tr><td><code>\u</code><td>convert next character to uppercase<tr><td><code>\L</code><td>convert following characters to lowercase, stops if <code>\U</code> or <code>\E</code> is found<tr><td><code>\U</code><td>convert following characters to uppercase, stops if <code>\L</code> or <code>\E</code> is found</table><br><h2 id=sed-delimiters>sed delimiters<a aria-label="Anchor link for: sed-delimiters" class=zola-anchor href=#sed-delimiters>🔗</a></h2><ul><li><code>/</code> is idiomatically used as the delimiter.<li>Any character except <code>\</code> and newline character can also be used. For example: <code>s#/home/learnbyexample/#~/#</code> is same as <code>s/\/home\/learnbyexample\//~\//</code>.<li>For regexp addressing, the first delimiter has to be escaped. For example: <code>\;/foo/bar/;p</code> is same as <code>/foo\/bar\//p</code>.</ul></div><div class=post-footer><div class=post-tags><a href=https://learnbyexample.github.io/tags/gnu-grep/>#gnu-grep</a><a href=https://learnbyexample.github.io/tags/gnu-sed/>#gnu-sed</a><a href=https://learnbyexample.github.io/tags/gnu-awk/>#gnu-awk</a><a href=https://learnbyexample.github.io/tags/regular-expressions/>#regular-expressions</a><a href=https://learnbyexample.github.io/tags/cheatsheet/>#cheatsheet</a><a href=https://learnbyexample.github.io/tags/linux/>#linux</a></div><p>👉 Use <a href=https://learnbyexample.github.io/atom.xml>this link</a> for the Atom feed. <br> 👉 Follow me on <a href=https://twitter.com/learn_byexample>Twitter</a>, <a href=https://github.com/learnbyexample>GitHub</a> and <a href=https://www.youtube.com/channel/UCKdFGbeOUPYM9GocmrIFGcw/playlists>Youtube</a> for interesting tech nuggets.<hr color=#e6e6e6></div></article></div></main></div><script src=https://learnbyexample.github.io/even.js></script>