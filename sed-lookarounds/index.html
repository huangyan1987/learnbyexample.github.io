<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><title>Emulating regexp lookarounds in GNU sed</title><link href=https://learnbyexample.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><link href=https://learnbyexample.github.io/site.css rel=stylesheet><meta content="Emulating regexp lookarounds in GNU sed" property=og:title><meta content=website property=og:type><meta content="A few workarounds when you want to keep using sed but need lookarounds as well." property=og:description><meta content=https://learnbyexample.github.io/sed_lookarounds/ property=og:url><meta content=@learn_byexample property=twitter:site><link href=https://learnbyexample.github.io/favicon.svg rel=icon><link rel="shortcut icon" href=https://learnbyexample.github.io/favicon.png><body><div class=container><div class=mobile-navbar id=mobile-navbar><div class=mobile-header-logo><a class=logo href=/>learnbyexample</a></div><div class="mobile-navbar-icon icon-out"><span></span><span></span><span></span></div></div><nav class="mobile-menu slideout-menu slideout-menu-left" id=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a href=https://learnbyexample.github.io/books> Books </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/mini> Mini </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tips> Tips </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tags> Tags </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/about> About </a></ul></nav><header id=header><div class=logo><a href=https://learnbyexample.github.io>learnbyexample</a></div><nav class=menu><ul><li><a href=https://learnbyexample.github.io/books> Books </a><li><a href=https://learnbyexample.github.io/mini> Mini </a><li><a href=https://learnbyexample.github.io/tips> Tips </a><li><a href=https://learnbyexample.github.io/tags> Tags </a><li><a href=https://learnbyexample.github.io/about> About </a></ul></nav></header><main><div class=content id=mobile-panel><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a class=toc-link href=https://learnbyexample.github.io/sed-lookarounds/#filtering>Filtering</a><li><a class=toc-link href=https://learnbyexample.github.io/sed-lookarounds/#substitution>Substitution</a> <ul><li><a class=toc-link href=https://learnbyexample.github.io/sed-lookarounds/#negative-lookarounds>Negative lookarounds</a><li><a class=toc-link href=https://learnbyexample.github.io/sed-lookarounds/#positive-lookarounds>Positive lookarounds</a></ul><li><a class=toc-link href=https://learnbyexample.github.io/sed-lookarounds/#summary>Summary</a></ul></nav></div></div><article class=post><header class=post__header><h1 class=post__title><a href=https://learnbyexample.github.io/sed-lookarounds/>Emulating regexp lookarounds in GNU sed</a></h1><div class=post__meta><span class=post__time>2020-10-31</span></div></header><div class=post-content><p>This <a href=https://stackoverflow.com/q/64371281/4082052>stackoverflow Q&A</a> got me thinking about various ways to construct a solution in <code>GNU sed</code> if lookarounds are needed.<blockquote><p><img alt=info src=/images/info.svg> Only single line (with newline as the line separator) processing is presented here. Equivalent lookaround syntax with <code>grep -P</code> or <code>perl</code> is also shown for comparison. Cases where multiple lines and/or ASCII NUL characters are present in the pattern space is left as an exercise.</blockquote><span id=continue-reading></span><br><h2 id=filtering>Filtering<a aria-label="Anchor link for: filtering" class=zola-anchor href=#filtering>🔗</a></h2><p>Here, you only need to decide whether the input line has to be matched or not. <code>sed</code> supports grouping commands inside <code>{}</code> that should be executed only if a filtering condition is matched. The condition could be negated by adding a <code>!</code> character. In this way, you can emulate chaining of multiple positive and/or negative lookaround conditions.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ cat items.txt
</span><span style=color:#b3933a;>1</span><span>,</span><span style=color:#b3933a;>2</span><span>,</span><span style=color:#b3933a;>3</span><span>,</span><span style=color:#b3933a;>4
</span><span>apple=</span><span style=color:#b3933a;>50 </span><span>;per kg
</span><span>a,b,c,d
</span><span>;foo xyz3
</span><span>
</span><span style=color:#7f8989;># lines containing a digit character followed by a ; character anywhere after
</span><span style=color:#7f8989;># lookaround isn't needed here
</span><span style=color:#7f8989;># same as: grep '[0-9].*;' or grep -P '\d(?=.*;)'
</span><span>$ sed </span><span style=color:#72ab00;>-</span><span>n </span><span style=color:#d07711;>'/[0-9].*;/p'</span><span> items.txt
</span><span>apple=</span><span style=color:#b3933a;>50 </span><span>;per kg
</span><span>
</span><span style=color:#7f8989;># lines containing both digit and ; characters in any order
</span><span style=color:#7f8989;># same as: grep -P '^(?=.*;).*\d'
</span><span>$ sed </span><span style=color:#72ab00;>-</span><span>n </span><span style=color:#d07711;>'/;/{ /[0-9]/p }'</span><span> items.txt
</span><span>apple=</span><span style=color:#b3933a;>50 </span><span>;per kg
</span><span>;foo xyz3
</span><span>
</span><span style=color:#7f8989;># lines containing both digit and ; characters
</span><span style=color:#7f8989;># but not if the line also contains character a
</span><span style=color:#7f8989;># same as: grep -P '^(?!.*a)(?=.*;).*\d'
</span><span>$ sed </span><span style=color:#72ab00;>-</span><span>n </span><span style=color:#d07711;>'/a/!{ /;/{ /[0-9]/p } }'</span><span> items.txt
</span><span>;foo xyz3
</span></code></pre><p>For some cases, multiple condition check like the previous examples is not enough. For example, filter a line if it contains <code>par</code> as long as <code>cart</code> isn't present later in the line. Presence of <code>cart</code> earlier in the line shouldn't affect the outcome. In such cases, you can first change the input line to add a newline character wherever <code>cart</code> is present and then construct a condition such that it depends on the newline character instead of <code>cart</code>. If a match is found, delete all the newline characters and then print the line.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'par carted spare cart park city\na parking cart\n'
</span><span>
</span><span style=color:#7f8989;># same as: grep -P 'par(?!.*cart)'
</span><span>$ </span><span style=color:#b39f04;>printf </span><span style=color:#d07711;>'</span><span style=color:#aeb52b;>%b</span><span style=color:#d07711;>' "$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span>n </span><span style=color:#d07711;>'s/cart/\n&/g; /par[^\n]*$/{ s/\n//g; p }'
</span><span>par carted spare cart park city
</span></code></pre><blockquote><p><img alt=info src=/images/info.svg> Newline is a safe character to choose for default line by line processing, as <code>sed</code> removes it from the pattern space. If you are processing a pattern space that contains newline character (for example: <code>-z</code> option, <code>N</code> command, etc), then you can still perform this trick as long as you know a character that is guaranteed to be absent from the input data.</blockquote><h2 id=substitution>Substitution<a aria-label="Anchor link for: substitution" class=zola-anchor href=#substitution>🔗</a></h2><p>In the previous section, you saw how to modify input line with newline character to make it easier to construct a lookaround condition. This trick comes in handy for substitution as well. However, for search and replace cases, you also need to emulate zero-width nature of lookarounds. To achieve this, you can make use of <code>t</code> command to construct a loop that performs substitution as long as a match is found. See my chapter on <a href=https://learnbyexample.github.io/learn_gnused/control-structures.html>Control structures</a> for more details about branching commands in <code>GNU sed</code>.<p>Here's an example of looping. Aim is to delete <code>fin</code> from the given input recursively.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># manual repetition, assuming count is known
</span><span>$ echo </span><span style=color:#d07711;>'coffining' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/fin//'
</span><span>cofing
</span><span>$ echo </span><span style=color:#d07711;>'coffining' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/fin//; s///'
</span><span>cog
</span><span>
</span><span style=color:#7f8989;># :loop marks the 's' command with label 'loop'
</span><span style=color:#7f8989;># tloop will jump to label 'loop' as long as the substitution succeeds
</span><span>$ echo </span><span style=color:#d07711;>'coffining' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>':loop s/fin//; tloop'
</span><span>cog
</span></code></pre><h3 id=negative-lookarounds>Negative lookarounds<a aria-label="Anchor link for: negative-lookarounds" class=zola-anchor href=#negative-lookarounds>🔗</a></h3><p>Some cases can be solved by performing substitution only if a condition is first satisfied. For this example, need to first select lines if it doesn't start with a <code>;</code> character. Then, for such lines, remove everything from the first space or comma character. Note that <code>{}</code> grouping is optional here.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># same as: perl -ne 'print if s/^(?!;).*?\K[ ,].*//'
</span><span>$ sed </span><span style=color:#72ab00;>-</span><span>n </span><span style=color:#d07711;>'/^;/! s/[ ,].*//p'</span><span> items.txt
</span><span style=color:#b3933a;>1
</span><span>apple=</span><span style=color:#b3933a;>50
</span><span>a
</span></code></pre><p>For this example, need to change <code>foo</code> to <code>[baz]</code> only if it is not followed by a digit character. Note that <code>foo</code> at the end of string also satisfies this assertion. <code>foofoo</code> has two matches as the assertion is zero-width in nature, i.e. it doesn't consume characters. Here, the first step is inserting a newline character between <code>foo</code> and a digit character. Then change all <code>foo</code> to <code>[baz]</code> as long as it is at the end of string or if it isn't followed by a newline character. Once the loop ends, remove all the newline characters.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'hey food! foo42 foot5 foofoo'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/foo(?!\d)/[baz]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>'s/(foo)([0-9])/\1\n\2/g;
</span><span style=color:#d07711;>                      :a s/foo([^\n]|$)/[baz]\1/; ta;
</span><span style=color:#d07711;>                      s/\n//g'
</span><span>hey [baz]d! foo42 [baz]t5 [baz][baz]
</span></code></pre><p>Change <code>foo</code> to <code>[baz]</code> only if it is not preceded by <code>_</code> character. <code>foo</code> at the start of string is matched as well.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'foo _foo 42foofoo'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/(?&LT!_)foo/[baz]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>'s/(_)(foo)/\1\n\2/g;
</span><span style=color:#d07711;>                      :a s/(^|[^\n])foo/\1[baz]/; ta;
</span><span style=color:#d07711;>                      s/\n//g'
</span><span>[baz] _foo </span><span style=color:#b3933a;>42</span><span>[baz][baz]
</span></code></pre><p>Replace <code>par</code> with <code>[xyz]</code> as long as <code>s</code> character is not present later in the input. This assumes that the assertion doesn't conflict with the search pattern, for example <code>s</code> will not conflict with <code>par</code> but would affect if it was <code>r</code> and <code>par</code>.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'par spare part party'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/par(?!.*s)/[xyz]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>'s/s/&\n/g;
</span><span style=color:#d07711;>                      :a s/par([^\n]*)$/[xyz]\1/; ta;
</span><span style=color:#d07711;>                      s/\n//g'
</span><span>par s[xyz]e [xyz]t [xyz]ty
</span></code></pre><p>Replace all empty fields with <code>NA</code> for csv input (assuming no embedded comma, newline characters, etc).<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>',1,,,two,3,,,'
</span><span>
</span><span style=color:#7f8989;># same as: perl -lpe 's/(?&LT![^,])(?![^,])/NA/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>':a s/,,/,NA,/g; ta; s/^,/NA,/; s/,$/,NA/'
</span><span style=color:#5597d6;>NA</span><span>,</span><span style=color:#b3933a;>1</span><span>,</span><span style=color:#5597d6;>NA</span><span>,</span><span style=color:#5597d6;>NA</span><span>,two,</span><span style=color:#b3933a;>3</span><span>,</span><span style=color:#5597d6;>NA</span><span>,</span><span style=color:#5597d6;>NA</span><span>,</span><span style=color:#5597d6;>NA
</span></code></pre><p>Replace if <code>go</code> is not there between <code>at</code> and <code>par</code>.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'fox,cat,dog,parrot,dot,park,bat,go,spare,sat-in-a-park'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/at((?!go).)*par/[xyz]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/go/\n&/g; s/at[^\n]*par/[xyz]/g; s/\n//g'
</span><span>fox,c[xyz]k,bat,go,spare,s[xyz]k
</span></code></pre><h3 id=positive-lookarounds>Positive lookarounds<a aria-label="Anchor link for: positive-lookarounds" class=zola-anchor href=#positive-lookarounds>🔗</a></h3><p>In this example, need to surround fields with <code>[]</code> except first and last fields for csv input (assuming no embedded comma, newline characters, etc). With positive lookaround emulation, the modified string may continue to satisfy the matching condition, resulting in infinite looping. In this example, the fields themselves may contain <code>[]</code> characters, so you cannot use them to prevent infinite loop. The newline character trick comes in handy again.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'1,t[w]o,[3],f[ou]r,5'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/(?<=,)[^,]+(?=,)/[$&]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>':a s/,([^,\n]+),/,\n[\1],/g; ta; s/\n//g'
</span><span style=color:#b3933a;>1</span><span>,[t[w]o],[[</span><span style=color:#b3933a;>3</span><span>]],[f[ou]r],</span><span style=color:#b3933a;>5
</span></code></pre><p>Add space at word boundaries, but not at the start or end of string. Also, don't add space if it is already present. Here, negated character class on space character is enough to emulate the assertion.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'total= num1+35*42/num2'
</span><span>
</span><span style=color:#7f8989;># same as: perl -lpe 's/(?<=[^ ])\b(?=[^ ])/ /g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>':a s/([^ ])\b([^ ])/\1 \2/; ta;'
</span><span>total </span><span style=color:#72ab00;>=</span><span> num1 </span><span style=color:#72ab00;>+ </span><span style=color:#b3933a;>35 </span><span style=color:#72ab00;>* </span><span style=color:#b3933a;>42 </span><span style=color:#72ab00;>/</span><span> num2
</span></code></pre><p>Replace <code>par</code> with <code>[xyz]</code> as long as <code>part</code> occurs as a whole word later in the line. Here, the nature of the modified string itself prevents the possibility of infinite loop.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'par spare part party'
</span><span>
</span><span style=color:#7f8989;># same as: perl -pe 's/par(?=.*\bpart\b)/[xyz]/g'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>':a s/par(.*\bpart\b)/[xyz]\1/; ta'
</span><span>[xyz] s[xyz]e part party
</span></code></pre><h2 id=summary>Summary<a aria-label="Anchor link for: summary" class=zola-anchor href=#summary>🔗</a></h2><p>Branching commands and some creative preprocessing of the input can be combined to emulate lookaround assertions in <code>sed</code>. Given that <a href=https://catonmat.net/proof-that-sed-is-turing-complete>Unix utility sed is Turing complete</a>, it's perhaps not a big surprise. Now, please excuse me, I'll be busy reaping points on stackoverflow/unix.stackexchange for this edge case ;)</div><div class=post-footer><div class=post-tags><a href=https://learnbyexample.github.io/tags/lookarounds/>#lookarounds</a><a href=https://learnbyexample.github.io/tags/regular-expressions/>#regular-expressions</a><a href=https://learnbyexample.github.io/tags/gnu-sed/>#gnu-sed</a></div><hr color=#e6e6e6><div class=post-nav><p><a class=previous href=https://learnbyexample.github.io/multiline-search-and-replace/>← Multiline fixed string search and replace with CLI tools</a><br><p><a class=next href=https://learnbyexample.github.io/substitution-with-ripgrep/>Search and replace tricks with ripgrep →</a><br></div><hr color=#e6e6e6><p>📰 Use <a href=https://learnbyexample.github.io/atom.xml>this link</a> for the Atom feed. <br> ✅ Follow me on <a href=https://twitter.com/learn_byexample>Twitter</a>, <a href=https://github.com/learnbyexample>GitHub</a> and <a href=https://www.youtube.com/c/learnbyexample42>Youtube</a> for interesting tech nuggets. <br> 📧 Subscribe to <a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>learnbyexample weekly</a> for programming resources, tips, tools, free ebooks and more (free newsletter, delivered every Friday).<hr color=#e6e6e6></div></article></div></main></div><script src=https://learnbyexample.github.io/even.js></script>